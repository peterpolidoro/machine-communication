---
layout: default
---

[Machine Communication](index)

[Project](project)

Imagine a researcher emails you and asks if you would like to work on a new
project. She wants to train a mouse to reach for a food pellet when it hears a
sound.

You do not know much about the researcher or her lab, but you know she studies
some sort of neural activity in the mouse brain as the mouse is reaching.
Perhaps she wants to increase the number of reaches, so she can collect more
data in a given amount of time, by training the to mouse to perform on cue.

This is a very vague project description so far. When I first hear about a
project I am tempted to focus on the details and start brainstorming. Play a
sound, play a sound, how many different ways can I think of to play a sound?

It is important, though, to first figure out the fundamental problem of a
project, what the researcher is really asking you, before diving into the
details of what they request.

Question your assumptions in the very beginning before investing time in any one
particular solution.

[Communication Diagram](communication)

I think that at the heart of this project is a communication problem.

This figure is from Claude Shannon's wonderful paper on the mathematical theory
of communciation.

[Human Brain to Mouse Brain Communication](brains)

The researcher wants to send a message from her brain into the brain of the
mouse, asking it to please reach out and grab a food pellet.

She needs a transmitter to convert her message into a signal, which can then be
sent through a channel to some receiver. The receiver will convert the signal
back into a message and deliver it to the mouse brain destination.

[Ear Receiver](ear)

The researcher asked you to use the mouse ear to receive messages and deliver
them to the mouse brain.

When you frame the problem like this, you see that perhaps there could be other
choices for the receiver. You might be able to use any mouse sense to deliver
messages to its brain, like flashing lights in its eyes, producing an odor, or
poking or vibrating it. Or maybe there is a way to deliver messages into its
brain with some sort of probe, bypassing its senses.

It seems reasonable to use the mouse ear as a receiver, so go with that for now.
You make a mental note, though, that perhaps you can try another receiver in the
future if necessary.

[Mouth](mouth)

Perhaps the most obvious way for a human to transmit a signal from her brain
into a ear is by using her mouth. Humans often transmit signals from their
mouths to other human ears when they want to communicate information.

Messages are going from my brain through my mouth into your ears and to your
brains right now.

Mice probably send each other information using their mouths and ears as well.

[Human and Mouse Languages](languages-human-mouse)

In order to transmit the information, however, you need to figure out a common
language between the mouse and the human.

In English, you want to be able to say something like "Reach for the food pellet
please." Now I have never trained a mouse, so I do not know if it is possible to
teach a mouse short English sentences like you might to a dog.

Another option is for the human to learn the equivalent in mouse language.
Perhaps some sort of ultrasonic "squeek, squeek, squeek" roughly translates, but
possibly no such mouse language exists.

[Droid Language](language-droid)

An alternative to using either human or mouse languages, would to make up a new
language and teach that to both the human and the mouse. Some sort of in between
language that is simplier for both to learn, like beeps or whistling tones, the
droid language of R2D2 for example.

[Whistle Solution](whistle)

Whistling a tone might work well. Farmers can teach dogs how to herd sheep this
way.

You email the researcher and tell her you have a great idea. It does not require
her to build anything or buy anything and it can be available immediately. Just
teach the mouse to reach whenever you whistle a tone.

She writes back, thank you, but she already knew she could whistle to it. She
likes the idea of using a tone, but not the idea of relying on her to whistle.

[Automated Experimental Rig](robot-feeding)

The project is a bit more complicated than just training the mouse.

The researcher is using some sort of experimental rig to automatically feed
pellets to the mouse.

The experimental rig does not necessarily look like the image shown, it could be
a rotating disk with food pellets on it, or some sort of X-Y-Z stage that
delivers pellets to a spot where the mouse can reach them.

For convenience, however, let us call this automated experimental rig "Rosie"
and ignore for now the specific details of how Rosie might operate.

[Automated Whistling](whistle-robot)

The issue with relying on the researcher to whistle, is that the researcher
would also like Rosie to ask the mouse to please reach for the pellet. Rosie
needs to play a sound right before presenting a new food pellet. This requires
that the researcher watch Rosie carefully to know when to send messages to the
mouse or have Rosie somehow communicate that to the researcher. Now the
automated experimental rig is no longer so automated.

[Another Transmitter](transmitter)

The researcher wants to be able to send messages to the mouse manually and
independently let Rosie send messages to the mouse automatically as well.

So the researcher wants you to go back to the drawing board and think of another
way to transmit sounds to the mouse.

The transmitter most certainly will not look like R2D2, but for now let us use
that as a place holder representation of whatever transmitter we end up using.

[Sound is Mechanical](sound)

Sound is a mechanical process of air vibrations acting on the mouse ear drum.

[Mechanical Transmitter](mechanical)

If sound is mechanical, perhaps you should try using a purely mechanical
transmitter.

You could use a metal whistle instead of your lips and that could improve tone
fidelity. It does not seem like it would be easy for Rosie to blow a whistle
though.

Purely mechanical devices are capable of quite complex behavior. You can
construct mechanical devices that play sounds at time intervals like a cuckoo
clock. You can encode an entire song onto a metal cylinder and play that song
simply by rotating a handle at the proper rate.

People have trained dogs using bells, perhaps a bell is all you need.

[Bell Solution](bell)

So you email the researcher and ask her what she thinks of using a little bell.

She can flick the bell with her finger when she wants to send messages to the
mouse and perhaps the bell can be mounted next to Rosie in such a way so that
some part of Rosie hits the bell and rings it before each food pellet is
delivered.

[Messaging the Bell](human-bell)

The researcher writes back that a bell might work, but she wants to be able to
change certain properties of the sound during the experiment like the tone
frequency and volume. This will help her during the training and the experiments
somehow.

So in addition to being able to send signals to the mouse using the bell, she
also wants to be able to send messages to the bell in order to changes its
properties.

[Human and Mechanical Languages](languages-human-mechanical)

So what are the language options you can use to communicate to a bell?

In English, you want to be able to say something like "Change the tone frequency
to 5000 Hz please." or "Change the tone volume to 50 % please."

How is it possible to send messages to something mechanical?

Information in mechanical devices is stored and transmitted kinetically. Mass is
distributed geometrically in 3D space and time with forces acting on it.

In order to change information stored in a mechanical device, you need to
physically move mass in the device or apply forces to it. You need to sculpt it
or machine it, push it, or distort it. You might flip a lever or turn a screw.

So just like we are using a whistle language instead of either a human language
or mouse language to communicate to the mouse, is it possible to come up with
some sort of intermediate language in between English and mechanical to
communicate to the bell?

[Knob Language](language-knob)

Perhaps you can use something like labeled mechanical knobs. Turning on the
knobs might pull on a spring or distort the bell or select between a thousand
little bells on a giant rotary tool changer. Maybe turning the volume knob
raises or lowers a sound muffling box over the bell. Adding labels to the knobs
allows the human to read and adjust the value in something like English, while
the physical position of the knobs communicate those values to the mechanical
device somehow.

One of the nice things about using an intermediate language is that it hides the
implementation details. That can free you up to change the implementation
details later if necessary, but not have to change the language that you are
speaking.

For example, say you are using an inexpensive electric stove at home to cook
food and you decide you want to upgrade to a fancy gas stove. The performance
and cost and other details may change, but the "Simmer, Low, Medium, High" knob
language will pretty much stay the same. You may have to adjust your cook times
slightly, but recipes from cookbooks will work with either stove without having
to be rewritten. If a cookbook said send four amps through the cooking coil for
10 minutes, then you would need to translate the cookbook for specific stoves.

The details have been abstracted away by the intermediate language.

[Human Knob Bell](human-knob-bell)

So now we have a potential way for the human to transmit information to the
bell. The receiver might be something complicated, but you can figure out the
details if the researcher likes your approach.

So you email her and tell her your idea of adding knobs to the bell.

[Human Robot Knob Bell](human-robot-knob-bell)

The researcher responds while the knobs might work for her, she also needs Rosie
to be able to send messages to the bell automatically so it can play different
tones during the experiments.

Since Rosie is most likely not anything resembling humanoid, without anything
resembling hands to turn the knobs, it might be very difficult for Rosie to use
the knob language to change the bell properties. Rosie also has the option of
using the bell's mechanical language directly, but that might require lots of
expensive modifications.

[Fly Alcohol Assay](fly-alcohol-assay)

This is a fly alcohol project that some of us here worked on years ago for
Ulrike's lab. There are six tunnels and one fly is placed into each tunnel. A
camera looked down at the tunnels and figured out in real time the location and
orientation of all of the flies. Three little gates in each tunnel could open
and let the fly run freely or close and trap a fly in a section of a tunnel. We
could then pump in odors or alcohol vapors.

Right after we got it to work, the researchers moved to Brown where they ran it
for a few years. I am not sure the researchers ever found anything of note
scientifically using this rig, so in that sense perhaps it was not a successful
project, but it was a overall it was a pretty clever little device and fun to
build.

We made a mistake on this rig, though, that made it difficult to use. There was
a complicated mechanical linkage that controlled the position of each gate. It
worked well if everything was adjusted just right, but if it was a little too
tight, the gates would jam, if it was a little too loose, the gates would fall
down when they were supposed to be closed. Every researcher using this rig had
to be trained how to adjust the linkage properly and do that before every
experiment. This was very frustrating for new researchers and it made them not
like using the rig.

This was something we could have pretty easily fixed with a simpler linkage in
another design iteration. We wanted to send two messages to the gates, open or
close and the linkage should have been correspondingly as simple. Something like
little spring loaded solenoids or flipping magnets might have worked.
Calibration, adjustments, and wear, are things you have to be careful about when
using a purely mechanical communication scheme.

Sometimes you have no choice but to require your mechanical parts to have very
high precision with reliable techniques for aligning them and calibrating them.
Optical components in a microscope are an example. Ideally, though, you can make
your design tolerant to imperfections, misalignment, and wear.

[Yet Another Transmitter](human-robot-transmitter)

So the researcher wants you to go back to the drawing board and think of yet
another way to transmit sounds to the mouse, one that will make it possible for
both her and Rosie to send messages to the transmitter to change its properties.

[Electro-Mechanical Transmitter](electro-mechanical)

How about using some sort of electro-mechanical transmitter?

If you are willing to add the complication of electronics to your transmitter
you can gain some interesting properties.

Electronics come at a cost. You need electrical power and electrical noise can
become audio noise corrupting your sound transmission. Electronics can be
senstive to environmental conditions. You might not want to add electronics to a
farmer's sound transmitter who is training his dog to herd sheep in the rain.

The sound transmission will still be mechanical. A speaker physically vibrates
the air. The speaker will be controlled, however, by electric signals and power,
opening up more possibilities for triggering the device and communicating to it.

[Human and Electro-Mechanical Languages](languages-human-electro-mechanical)

So now which language options can we chose?

In human language, you still want to be able to send messages to the device,
like "change the frequency" and "change the volume".

In electro-mechanical language, you still have the option of using mechanical
knobs and levers to change information stored in the system.

Adding electronics, however, also gives you the option of changing information
in the device by modifying component values and electric signals.

Many electronic components are mass produced in many different values. It can be
much easier and faster to swap a resistor for one with a different value than to
remachine a mechanical part to have new geometry.

Electronic knobs can change component values directly and you can use switches
and buttons and sensors to change properties of the circuit both manually and
with feedback.

[Electro-Mechanical Transmitter](pcb)

Now say you have either bought or built an electro-mechanical transmitter that
can play tones. Perhaps the researcher can trigger a tone by pressing a button
and Rosie can trigger a tone by sending it an electric signal or by closing a
switch.

[Talking To the Electro-Mechanical Transmitter](human-robot-pcb)

When the researcher wants to send messages to the electro-mechanical
transmitter, perhaps she can turn potentiometer knobs to change the frequency or
volume of the tone.

When Rosie wants to send messages to the electro-mechanical transmitter, she
could change the value of analog voltage signal. Increasing the voltage might
increase the tone frequency.

Lots of rigs and devices in this building use variations of this analog voltage
language. Some people love using analog voltages because you can look at them on
an oscilloscope and vary them by turning knobs. Sometimes it is unavoidable like
when a sensor only outputs an analog voltage or some device only accepts analog
input.

There is a drawback of using analog voltages to send messages, however, and that
is the part of the communication diagram we have been ignoring up until now:
noise.

[Signal Noise](signal-noise)

Every signal contains some amount of noise. You want to send a nice sine wave,
but noise makes it look less than perfect. Perhaps a little bit of noise is not
a big deal. If you accidentally set the frequency to 5010 Hz instead of 5000 Hz
because of noise, the mouse will probably not notice the difference.

There are techniques for minimizing noise and maximizing signal, like shielding
wires and using differential signals, but it is always going to be there to some
extent.

[Light Sensor](light-sensor)

Here is another project that I worked on years ago that only used analog
circuitry. It is a light sensor for detecting IR light reflecting off of fly
wings. Researchers use it to tell how fast a fly is flying and as a way to
detect when flying starts and stops.

After a couple of iterations I got it to work well and it was used by Sung Soo
in a rig here and by other labs in several universities.

The first iteration of my design, though, I did something pretty stupid in
retrospect. I needed a nice bandpass filter to remove noise and the large DC
component of the signal. Ideal bandpass filters have nice sharp edges where
everything outside the frequency range is squashed to zero and everything inside
the range passes unchanged. Real filters are never so nice, but by adding orders
to the filter in stages you can better approximate an ideal filter. Filters
might reduce the signal, but by adding a gain stage afterwards you can increase
the signal back up to where you want it.

I wanted a really nice filter so I used four filter stages with an amplifier at
the end. This worked great when I simulated the filter, but in reality, each
stage reduced the signal more and more until it was the same magnitude as the
noise and when I amplified it at the end the noise was amplified too and the
resulting waveform looked horrible.

I fixed the filter by putting smaller amplifiers after each stage instead of one
big one at the end. Noise is always something you have to deal with properly in
analog circuits to get good results.

[Copy Degradation](copy-degradation)

One thing you definitely do not want to do with analog signals, though, is copy
them over and over again.

Say the researcher sends you another email telling you she needs to record all
of the signals in the experiment so she can analyze them later or send them to
others. Perhaps you can tap into the analog message signal and record it to a
magnetic tape or use a tape recorder and a microphone to save the transmitted
sounds. If someone makes a copy of that tape and then a copy of that copy and so
on, even small amounts of noise will accumulate and make the copies signals
worse than the originals.

[Going Digital](threshold)

So instead of using and analog signal, you can instead use a digital one.

You can create a digital signal from an analog one by using a threshold half way
in between the lowest voltage and highest voltage. Anything value over the
threshold becomes the maximum voltage and anything below the threshold becomes
the minimum voltage.

At first that may not seem like such a good idea since you are throwing away
information, with potential discretization errors and rounding errors.

[Threshold Noise](threshold-noise)

Just drawing a threshold does not fix noise problems. A noisy signal can cross
the threshold multiple times creating artifacts in the digital signal.

[Schmitt](schmitt)

You can make it more immune to noise by using two threshold values instead of
one. When the output signal is high, the input signal needs to go all the way
down to the lower threshold before it switches low output. When the output
signal is low, it needs to go all the way up to the high threshold to switch to
the high output.

If the difference in thresholds is larger than the noise, then the output signal
will no longer have noise artifacts.

[Postel](postel)

Postel proprosed a robustness principle as a design guideline for software. Be
conservative in what you do, be liberal in what you accept from others.

We may think of this as a general guideline for how devices can play well with
others. If you accept messages or signals that do not quite meet specifications
then you can work with devices with flawed outputs. If you only send messages or
signals that do meet specifications then you can work with devices that cannot
handle flawed inputs.

A mechanical analogy might be if you are machining a part that needs to bolt
onto a 3D printed part. You might want to open up the clearance holes if
possible in case the printed holes are a little off. You want to make sure all
of the locating features that other parts rely on are machined to tolerance
however.

[Noise Margin](noise-margin)

If you acceptable intput range is larger than your output range in your
electrical components, then you have added a noise margin that rejects noise
below a threshold in between your components.

[R2D2 and C3PO](r2d2-c3po)

When I was a kid, I always wondered why C3PO was fluent in over six million
forms of communication while R2D2 seemed only able to speak one. Why could they
not just put the chips from C3PO's head into R2D2's as well? The answer, of
course, is that it is just a movie and we should not over analyze it, but
perhaps R2D2 is conforming to Postel's Principle. C3PO does not seem to need to
translate what people say to R2, perhaps R2 can understand six million
languages, but can only speak one. Maybe this is important in battle situations
so there is never any confusion about which language to use. Or maybe there are
low level components in an X-Wing fighter that only speak droid so he wants to
make sure they understand him at all times.

[Digital versus Analog](digital-analog)

Digital signals introduce their own set of issues, but in general they are
preferable to analog whenever possible. They can be copied over and over again
perfectly as long as noise remains below some threshold. If a sensor outputs an
analog signal, then you should convert it to digital before transmitting the
value. If a digital device needs to send a message to another digital device,
then it is not a good idea to use an analog signal to pass messages between
them, making the messages susceptible to noise.

[PWM](pwm)

So if digital signals only have two values, how can you encode more elaborate
messages than a simple HIGH or LOW, or true or false, or yes or no?

Well in addition to the two voltage values, a digital signal also has timing
information of the rising and falling edges.

The ratio of the time that the signal is HIGH to the time of a full signal
period is referred to as the duty cycle. The duty cycle is used to transmit
position commands to hobby servos. Duty cycle can also be used to vary the
brightness of LEDs or the speed of brush motors in a very linear way or transmit
power in a very efficient way.

One issue to note is that while using digital signals help make messages immune
to noise, using digital signals to transmit power may generate noise, so you
need to handle that appropriately if necessary.

[Step and Direction](step-dir)

Another way to encode information in digital signals is to use step and
direction pulses or trigger signals. The edges of the signals are used to count
out values or trigger something to happen. These signals are a nice way to
trigger cameras to acquire images simultaneously or to control the motion of
linear stages or motors. Every rising edge, for example, may cause the motor to
move a fixed amount. So low frequency pulse cause the motor to rotate slowly and
high frequency pulses cause the motor to rotate quickly and you can accelerate
and decelerate and cause them to move by precise amounts. Encoders output these
step signals to measure position and velocity.

Instead of measuring voltage you are measuring timing, which in digital circuits
means counting clock pulses. Counting is often much easier than measuring.

[Hybridizer](hybridizer)

Here is an example of a project where I really wish I had counted instead of
measured.

This is the very clever hybridizer fluid handling machine designed by Jeff. We
got it to work well and it will be used for the next few years by a lab that
moved to Germany. It dispenses precise amounts of various fluids into a well
plate below it and shakes them and heats them and drains them.

We made a choice in the beginning of the project that made the controls
difficult for me. We were under the impression that we needed to be able to
dispense high volumes of fluid very quickly into the well plates. So we chose to
use these very large 10 mL cylinders above each of the six wells. If we only
wanted to dispense 6 mL of fluid, then we needed to fill each cylinder 60 % of
the way full by stopping the piston at the appropriate location as it was
filling the cylinder. We measured the location of the pistons using magnets and
hall effect sensors. The signals were very noisy and there was lots of cross
talk between sensors. I spent most of my time on the project just trying to
improve the accuracy of the piston measurements.

It would have been a way easier control problem if we had used really tiny
cylinders that would could fill and dispense very rapidly. If we had 100 uL
cylinders then we would have just needed to count out 60 full dispenses of a
small volume instead of trying to measure 60 % of a large volume. The entire
machine could have been much smaller and more accurate. It turned out we could
not dispense the fluid into the wells very quickly anyway since it would spill
out over the sides unless you filled it slowly. So I had to add extra code to
slow down the dispense, obsoleting the entire design choice in the first place.

[Zeros and Ones](zero-one)

Another way to encode information in digital signals is to split the signal into
fundamental units of time and the voltage values at those times are bits of
information.

In our step language or trigger language we would count the edges of the signal.
Now instead of counting the edges, we sample the signal at every unit of time.
We can label those values HIGH and LOW as before or we can assign them the
values of 1 and 0 so we can do math on them.

[Digits](digit)

Now we can use the 1 and 0 values as digits and encode information according to
their positions. To send the number 172 in the step language we would have
needed to clock out 172 rising edges or 172 times 2 bits. That is not a very
efficient way to encode a number. When controlling motion, it is not necessarily
important for encoding to be efficient. The motor will need to make steps one at
a time anyway, so by incrementing the number one at a time we have fine tuned
control of the speed.

If we want to transmit large numbers as messages very quickly, however, it can
be very important to encode the numbers more efficiently. Just as we encode the
number 172 in the base 10 decimal system with three digits, 100 plus 70 plus 2,
we can also encode the number 172 in the base 2 binary system with 8 digits,
much fewer than 172 times 2 we needed before.

[Binary](binary)

Binary numbers are encoded very efficiently, but decoding them requires caution.
Both the encoder and decoder need to agree in advance on the exact formatting of
the encoding. You cannot tell simply by looking at a binary number how it is
encoded.

This large binary sequence, for example, may encode four 8 bit values of 172 one
after the other. Or it may encode the 16 bit value of 44204 and then two eight
bit values. Or it may encode one giant 32 bit number or the 16 bit and 8 bit
values may be rearranged. If the encoder needs to be changed, like if you have
run out of values of an 8 bit number and need to increase it to a 16 bit number,
the decoder needs to be notified of the change, otherwise it will decode the
numbers incorrectly.

[String](string)

Another way to encode information is to use a larger number of bits to represent
a character. A set of characters is referred to as a string. This is a less
efficient way to store and transmit information than binary numbers, but the
advantage is that you gain lots of additional characters that can be used to
figure out what the string contains without knowing in advance.

[JSON](json)

JSON is a very popular string format for storing and transmitting information.
It has the advantage of being very readable to a human while at the same time
being able to encode complicated data structures that can be easily parsed by a
computer.

In JSON, curly braces are used to used to indicate an object of key value pairs.
Square brackets indicate arrays of whatever length you want. You can have
numbers, negative numbers, long numbers, booleans, and you can easily figure out
which is which just by looking at the first character of each.

I like using JSON to encode information when I can, even though it is not the
most efficient use of bits.

[Processor](processor)

If you are willing to add even more complication to your electro-mechanical
transmitter, you can throw in a processor.

[Instruction Set Architecture](machine-code-instruction-set)

Processors allow you to encode operations into your binary values. You can set
aside some number of bits to be an opcode, like add or subtract, and other bits
to be used as the addresses of registers on which to operate. With only a
relatively small number of opcodes you can perform extremely complex calculations.

[Human and Processor Languages](languages-human-processor)

Now back to our sound transmitter. Here are our new language options.

Processors store and transmit information digitally and process that information
using a machine code instruction set.

Binary data and machine code might look much more complicated at first than
simple resistor values or knob settings, but changing information in the
processor can be much faster and less painful than resoldering a part on a
circuit board or resizing a gear.

[Software Language](language-software)

Just as we were able to find intermediate languages in between human and
mechanical and electro-mechanical devices, high-level software adds abstraction
to machine languages to make them very similar to natural human languages.

Now we can write something that looks almost like English that asks the mouse to
reach for a pellet. This calls another English like function name that plays a
tone through the speaker. Similar language can be used to set the tone frequency
and volume.

In addition to english like languages, we can use more visual languages like
computer aided design or GUIs. These languages have the advantage of mechanical
intuition combined with the speed and easy of changing digital data rather than
physical mass.

[Software-Electro-Mechanical Transmitter](software-electro-mechanical)

There are many options for hardware that contain a processor and the electronics
necessary to control a speaker.

There is a huge variety of desktop and laptop computers, all of which can be
made to play sounds through a speaker.

Phones have a great user interface and have speakers built-in. Hey Siri, play a
tone at 5000 Hz please. It might not be a good idea to use a phone during an
experiment, though, in case you need to make a call.

There is also a large variety of circuit boards that contain processors, made by
many different companies and organizations.

Any one of these options could be used to make a nice sound transmitter. Most
people who write software might chose to use a desktop computer. After setting
up many experimental rigs, though, I think that any processor used to control an
experiment should not run any software that is not necessary for the experiment
controls.

The people who write operating systems are extremely intelligent and operating
systems are super convenient, but they are always doing lots of things behind
the scenes that can potentially affect the experiment. Just the other day we had
an experimental computer update and restart itself right in the middle of a week
long experiment. Dropbox may decide to sync or a video in a web browser may take
control of a speaker output.

I think it is best to use a dedicated processor for the sound transmitter and
only run software on it related to the sound transmission.

Raspberry Pi boards are nice and inexpensive, but the operating system makes it
non-deterministic.

Arduino boards are nice, but the lack of resources can be severely limiting. You
can learn a lot about programming by trying to fit everything in a couple
thousand bytes of RAM, but having more RAM allows for much richer behaviors.

This Teensy board with an attached audio board is a nice choice. The board
schematics and software are all open source allowing it to be easily modified.
You do not need to buy any expensive software or hardware licenses making them
almost disposable they are so cheap. Let us choose this for our sound transmitter.

[Teensy Transmitter](teensy-transmitter)

The researcher and Rosie can both use the electrical trigger language to tell
the Teensy transmitter to play tones. The researcher could press a button and
Rosie could toggle the voltage level on an electrical line.

[Communicating to the Teensy](human-robot-teensy)

What language can we use send messages to the Teensy transmitter?

[Open Systems Interconnection](osi)

The Open Systems Interconnection model partitions a communication system into a
set of abstraction layers. The goal is the interoperability of diverse
communication systems with standard protocols. The lowest level defines the
physical medium of communication, whether it is over wires or wireless, RS-232
or CAN bus or any other possible communication mediums. Abstraction layers are
added on top of this layer, allowing the same higher level language to be use
regardless of how the lower layers are implemented. The particular
implementation may affect the performance or cost or other factors of the
communication, but any low level may be used as long as they match on both the
transmitter and receiver. I am interested in what higher level languages, closer
to the top of the abstraction layers, may be used to communicate between
devices.

[Wild West](wild-west)

Of course it would nice if everything in the world used the exact same language
so anything could seemlessly communicate with anything else. When I first
started building devices, I made up a new little language for each one. It was
turning into a support nightmare to keep track of them all. Years ago I looked
around for some sort of common language that I could use to send messages to all
of my devices. What I found is that there is no standardized format, there are
hundreds or thousands of different schemes. Many companies come up with their
own little language and you either need to find the proper driver for your
interface language of choice or write your own by reading manuals and
datasheets.

Many devices have schemes similar to a two letter command string. Lots of other
devices use some sort of binary format where every byte has to match on the
transmitter and receiver sides. I found one format called JSON-RPC that seemed
promising. It sends command messages in JSON format for doing remote procedure
calls on computers across a network.

[JSON-RPC](json-rpc)

The JSON-RPC format specifies that you need to send a JSON object as a request,
with a set of key value pairs giving details about the method call. There is a
method field with an optional parameters field. I like this format, it is very
readable and flexible, while remaining relatively compact, at least compared to
other formats like XML.

I wanted something even more compact, though, so I made a slight modification
that allows JSON array requests as well as object requests. The first item in
the array specifies the method, with zero or more parameters following in order.
JSON has enough redundancies where even this can be made more compact by leaving
out the square brackets and commas, leaving a string that looks more like a bash
command. This makes it very easy for a human to send it messages while still
being easy for a little microprocessor to parse it properly and quickly.

[Sound Transmitter](sound-transmitter)

On top of this JSON-RPC format I added the concepts of a device that has
functions with parameters, properties that allow values to be modified and
stored while the device is running, and callbacks, functions that take no
parameters that can be attached to physical pin interrupts. Just by sending the
device a single question mark character, you get back a response describing the
device and some of what it can do.

I created a sound transmitter that can play tones in a range of frequencies and
volumes, with a tone playing callback that can be triggered by button presses or
pin voltage changes. The callback uses property values to determine the
frequency and volume of the tone it plays.

[Play Tone](play-tone)

You can ask the device to give you more information about the playTone function.
It reports back that it takes two parameters, first the frequency with a range
from 0 to 22000 Hz, and the second parameter is the volume, with a range of 0 to
100 Hz. You can play a tone by sending a string containing the name playTone and
the two integer values of the frequency and volume.

[Trigger Tone](trigger-tone)

Likewise, you can ask the device to give you information about the triggerTone
callback. It tells you that it is attached to both a button for humans to press
and a BNC input for being triggered from other electronic devices. It uses the
values of three properties, triggerToneFrequency, triggerToneVolume, and
triggerToneDuration.

[Trigger Tone Frequency](trigger-tone-frequency)

You can get information about properties just like you can about functions and
callbacks. You can see information like the currently set value, the default
value, and the value range and units. You can change property values and they
will remain changed even when the device is powered off and on again.

[Get Device Information](get-device-info)

You can get more information about the device, such as the firmware and
hardware.

[Future](future)

I am happy with this little language and the features it enables, but in the
future I may want to make some significant additions or modifications.

I noticed that the commands I am sending the device are almost identical to
lisp. Lisp is one of the most ancient high level languages. It has this very
interesting property of homoiconicity. The code is the same form as data and can
be modified as it is running. Since JSON does not use parentheses and that is
all lisp uses, it is possible to use both the JSON-RPC format and a lisp format
simultaneously. This could allow devices to modify each other's code as they are
running and connected to each other setting up some very powerful and
interesting ways of interacting.

I also found a project called the hardware operating system where people are
working on very similar concepts. They pass messages in a binary format, so
perhaps this scheme could be used simultaneously as well.

[Human Communication](human-human)

The ultimate goal of all of this is for humans to be able to transmit
information, ideas, discoveries, and creations to each other.
